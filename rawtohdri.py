#!/usr/bin/env python2.7
##############################################################################
### User configurable stuff ##################################################
##############################################################################
# Define maximum number of processes to run at once (multiprocessing threads)
# ( at present, rawtohdri never runs more processes than the chunk size. )
MAX_WORKERS = 3

# Define Temp DIR for intermediate 16 bit ppm files generated by dcraw. For
# best performance, this should be a different spindle than the out exr
# If you have the RAM for it, /dev/shm/ may be faster than disk

#TEMP_DIR = '/dev/shm/'
TEMP_DIR = '/tmp/'

# Rotate image amount [0,90,180,270] empty str = camera sensor angle
ROTATE = '-t 270 '
# ROTATE = ' '

##############################################################################
####### END OF USER CONFIGURABLE STUFF #######################################
##############################################################################
""" 
    rawtohdri - A tool for stacking camera raws into OpenEXR HDR images
         Copyright 2011 Aaron Estrada  |  bin.echo@gmail.com
         
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>
"""
import os
import sys
import argparse
import numpy as np
import OpenEXR, Imath
from multiprocessing import Pool
from subprocess import Popen, PIPE

PNAME = 'raw2hdri'
VERSION = '0.1.0'
PROG_DESC = """
%(prog)s batch-processes bracketed camera RAW files into exr format HDR
images. It works with any raw file format dcraw supports. The only required
argument is INPUT_RAW_DIR, in which case the default behavior is to dump the
resulting HDRIs in the INPUT_RAW_DIR with the file name hdrout_%%04d.exr. The
output images may alternately be nested in a dir named exr inside the input
dir using the -n flag.  The size of the bracket steps may be set with the -e
flag ( Default = ev 3 ). %(prog)s assumes bracketed images are ordered darkest
exposure to brightest.
"""

EPI = 'Examples: ( Put some examples here )'

VSTR = PNAME + ' Version: ' + VERSION + ' Copyright 2011 Aaron Estrada <bin.echo@gmail.com>'

# Various ways to call dcraw
DCRAW  = 'dcraw -h -q 3 -4 -w -c '+ROTATE
DCRAWV = 'dcraw -h -v -q 3 -4 -w -c '+ROTATE

def getargv(argv):
        """Returns args as dictionary ( key:value pairs ) """

        prsr = argparse.ArgumentParser(prog=PNAME, description=PROG_DESC, epilog=EPI)

        # Add arguments
        prsr.add_argument('input_dir', default=None,
            help='Directory containing raw files')

        prsr.add_argument('-x', '--chunk', type=int, default=3,
            help='Number of images per HDR stack (Default = %(default)s)')
        prsr.add_argument('-e', '--ev', type=int, default=3,
            help='Bracket exposure value (Default = %(default)s)')
        prsr.add_argument('-c', '--center', type=int, default=2,
            help='Center bracket. Second exposure (Default = %(default)s)')
        prsr.add_argument('-n', '--nest', action='store_true',
            help='Nest outputs in dir named "exr" in input dir (Default = %(default)s)')
        prsr.add_argument('-o', '--output-basename', default='hdrout_',
            help='Base name of output images (Default = "%(default)s)"')
        prsr.add_argument('-d', '--output-dir', default=None,
            help='Output images directory (Default = input_dir)')
        prsr.add_argument('-l', '--lo', type=float, default=0.7,
            help='Low clip value (Default = %(default)s)')
        prsr.add_argument('-H', '--hi', type=float, default=0.8,
            help='Hi clip value (Default = %(default)s)')
        prsr.add_argument('-v', '--verbose', action='store_true',
            help='Turn on verbose output in Workers')
        prsr.add_argument('--version', action='version', version=VSTR)

        # Parse arguments
        ns = prsr.parse_args(argv)

        # Convert attributes to a dictionary
        args = vars(ns)

        if args['nest'] == True:
                args['output_dir'] = os.path.join(args['input_dir'], 'exr')
        # Make sure ouput_dir has something useful in it no matter what
        if args['output_dir'] == None:
                args['output_dir'] = args['input_dir']               

        return(args)

def getFiles(dir):
    """Get list of files from 'dir' and returns list of those files with absolute path from /"""
    files = []
    for file in sorted(os.listdir(dir)):
        file = os.path.abspath(dir+file)
        files.append(file)
    return(files)

def getMeta(file):
    """Get metadata from raw file using dcraw. Returns dict."""
    COMMAND = 'dcraw -i -v '+file
    f = os.popen(COMMAND)
    parsed = f.read().split('\n')
    f.close()
    parsed.remove('')
    parsed.remove('')
    data = []
    for i in parsed:
        m = i.split(': ')
        data.append(m[1])
    meta = dict()
    meta['date']    = data[1]
    meta['camera']  = data[2]
    meta['iso']     = data[3]
    meta['shutter'] = data[4]
    meta['aperture']= data[5]
    meta['focal']   = data[6]
    return meta

def chunk(l, n):
    """
    Yield successive n-sized chunks from list or string. ( Using a Generator )
    Examples: 
    print(list(chunk(range(75), 10)))
    lol = [group for group in chunk(array, 3)]
    chopping up a string into an array: myArray = [group for group in chunk(string, 5)]
    """ 
    for i in xrange(0, len(l), n):
        yield l[i:i+n]

def sh(cmd):
    """
    cmd must be structured /exactly/ as /bin/sh would expect to see it. (Including any escapes etc.) 
    Calls /bin/sh and waits for subprocess to complete before exiting.
    This is basically just a wrapper so we can use Pool.map() method with shell=True
    We use shell=True to encapsulate the pipes and stuff used by our shell one-liners.
    """
    p = Popen(cmd, stdout=PIPE, shell=True)
    sys.stdout.write(p.communicate(input=None)[0])
    sys.stdout.flush()
    Popen.wait(p)

class PPM:
    """Wrapper class for making pythonic ppm read-only file objects.
        Upcasts input depth to float as each line is read.
        Expects file handle as only argument. Returns NumPy array
        of 'float_' (which is Python float64 compatible)
        
        myppm = PPM(file('ppmFile', 'rb'))
        
        Iterator returns next scanline for next().
    """
    def __init__(self, ppmFileObject):
        self.f16 = np.float_(1.0/65535)
        self.f8 = (1.0/255)
        self.data = ppmFileObject
        self.type = self.data.readline().strip()
        self.rez = self.data.readline().strip().split()
        self.colors = int(self.data.readline().strip())
        self.w = int(self.rez[0])
        self.h = int(self.rez[1])
        try: self.type == 'P6'
        except: print 'Only binary ppms are currently supported.'
        if self.colors == 65535:
            self.dtype = np.uint16
            self.depth = 16
        elif self.colors == 255:
            self.dtype = np.uint8
            self.depth = 8
            print 'WARNING: Unsupported PPM depth. Only 16 bit PPMs are currently supported!'
        else:
            self.dtype = np.uint8
            self.depth = 8
            print 'WARNING: Unsupported PPM depth. Assuming byte sized pixels. (Only 16 bit PPMs are currently supported!)'
    
    def __iter__(self):
        self.data.seek(0) # Jumps to head of file and move pointer past header by reading lines since I'm not clever enough to do it some other way.
        self.type = self.data.readline().strip()
        self.rez = self.data.readline().strip().split()
        self.colors = int(self.data.readline().strip())
        self.w = int(self.rez[0])
        self.h = int(self.rez[1])
        self.index = self.h
        return self
    
    def next(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.readline()
    
    def readline(self, lines=1):
        """Number lines number of scanlines to read from PPM file.
        Returnes as NumPy Array of floats. It's your job to know how
        many lines there are in the raster and do the right thing when calling
        this function manually. Consider using __iter__() and next() instead.
        """
        items = lines * self.w * 3
        return np.multiply(np.fromfile(self.data, dtype=self.dtype, count=items, sep='').byteswap(), self.f16)
    
    def read(self, size=None):
        """Read size number pixels, returned as interleaved 1D NumPy array.
        If the size argument is negative or omitted, read until EOF is reached.
        """
        if size == None:           
            return np.multiply(np.fromfile(self.data, dtype=self.dtype, count=-1, sep='').byteswap(), self.f16)
        elif size <= 0:
            return np.multiply(np.fromfile(self.data, dtype=self.dtype, count=-1, sep='').byteswap(), self.f16)
        else:
            items = size * 3
            return np.multiply(np.fromfile(self.data, dtype=self.dtype, count=items, sep='').byteswap(), self.f16)
    
    def close(self):
        self.data.close()

def lumaClip_(p, lo=0.65, hi=0.85):
	"""
	Makes a matte value for line p based on luma. Expects floating-point input.
	Returns 1 for values under lo. Returns lerped values from 1 to 0 to hi
    lo should always be a lower value than hi ... ie lumaClip(p, 0.8, 0.95)
	"""
	if p >= hi:     
		return 0.0
	if p < lo:
		return 1.0
	else:
		return (hi+(-1*p))/(hi-lo)
lumaClip = np.vectorize(lumaClip_)

def ev2ef(ev):
    """Converts stops to linear 'exposure factor'"""
    if ev <= 0:
        return 2.0**abs(ev)
    else:
        return 1.0/2**ev

def hdrStackLines(bg, fg, ev, lo=0.65, hi=0.85):
    """
    Generates matte for fg based on lo and hi cut
    Mults fg line values by ev stops and "overs" on bg based on matte
    """
    exposureFactor = ev2ef(ev)
    fgMatte = lumaClip(fg, lo, hi)
    scaled_fg = np.multiply(np.multiply(fg, exposureFactor), fgMatte)
    return np.add(np.multiply(bg, np.subtract(1.0, fgMatte)), scaled_fg)

if __name__ == '__main__':
    args = getargv(sys.argv[1:])
    files = getFiles(args['input_dir'])
    # Sanity checks
    if len(files)%args['chunk'] != 0:
        print 'Input file list is not a multiple of chunk size: ', args['chunk']
        sys.exit(22)
    if args['center'] > args['chunk']:
        print "'center' image index exceeds size of chunks!"
        sys.exit(22)
    if not os.path.exists(args['output_dir']):
        os.mkdir(args['output_dir'])
    if args['verbose'] == True:
        DCRAW = DCRAWV
        
    stacks = list(chunk(files, args['chunk']))
    # Finally... let's process some files!
    for stackIndex, stack in enumerate(stacks):
        cmdlist = []
        tmplist = []
        for f in stack:
            cmd = DCRAW+f+' > '+TEMP_DIR+f.split('/')[-1]+'.PPM'
            tmp = TEMP_DIR+f.split('/')[-1]+'.PPM'
            cmdlist.append(cmd)
            tmplist.append(tmp)
        print 'Processing stack:'+str(stackIndex+1)+'/'+str(len(stacks))
        print 'Debayering...'
        pool = Pool(processes=MAX_WORKERS)  # start worker processes.
        pool.map(sh, cmdlist) # run each cmd in list in a subprocesses until they are all done
        pool.close()
        layers = [ PPM(file(fileIn, 'rb')) for fileIn in tmplist ]
        meta = getMeta(stack[args['center']-1])
        HEADER = OpenEXR.Header(layers[0].w, layers[0].h)
        HEADER['channels'] = dict([(c, Imath.Channel(Imath.PixelType(Imath.PixelType.HALF))) for c in HEADER['channels'].keys()])
        HEADER['comments'] = 'Made with rawtohdri '+VERSION+' by Aaron Estrada'
        HEADER['camera']  = meta['camera']
        HEADER['date']    = meta['date']
        HEADER['iso']     = meta['iso']
        HEADER['aperture']= meta['aperture']
        HEADER['shutter'] = meta['shutter']
        HEADER['focal']   = meta['focal']
        OUTFILE = args['output_dir']+'/'+args['output_basename']+'%04d.exr' % (stackIndex+1)
        exr = OpenEXR.OutputFile(OUTFILE, HEADER)
        print 'Starting HDR stacking of',len(stack), layers[0].w,'x',layers[0].h, 'resolution images ...'
        bg = layers.pop(0)
        
        for lindex, output in enumerate(bg):
            ev = args['ev']
            for layer in layers:        
                output = hdrStackLines(output, layer.readline(), ev, args['lo'], args['hi'])
                ev = ev + args['ev']
            #Adjust output to "center" exposure.
            output = output*(2.0**(xrange(0,999999,args['ev'])[args['center']-1]))
            R,G,B = np.column_stack(output.reshape([len(output)/3, 3]).astype(np.float16))
            sys.stdout.write("\r Writing Scanline: ")
            sys.stdout.write(str(lindex+1))
            sys.stdout.flush()
            exr.writePixels({'R': R.tostring(), 'G': G.tostring(), 'B': B.tostring()}, 1)
        
        bg.close()
        for ppm in layers: ppm.close()
        exr.close()
        print ' ... DONE!'
        print '  Wrote', OUTFILE     
        print '   Blowing away temp files...'
        for tmpFile in tmplist: os.remove(tmpFile)
        
    print 'Finished processing '+str(len(files))+' raw files into '+str(len(stacks))+' HDRIs'

